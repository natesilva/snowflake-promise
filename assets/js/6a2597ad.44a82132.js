"use strict";(self.webpackChunksnowflake_promise_website=self.webpackChunksnowflake_promise_website||[]).push([[1424],{1636:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"implementation-details","title":"Key Implementation Details","description":"This page discusses selected implementation details of the library.","source":"@site/docs/implementation-details.mdx","sourceDirName":".","slug":"/implementation-details","permalink":"/snowflake-promise/docs/implementation-details","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authentication and MFA","permalink":"/snowflake-promise/docs/authentication-and-mfa"},"next":{"title":"Legacy Migration Guide","permalink":"/snowflake-promise/docs/migration-guide"}}');var s=t(4848),o=t(8453);const l={},a="Key Implementation Details",r={},d=[{value:"Proxying the Connection",id:"proxying-the-connection",level:2},{value:"Adding Promise Support While Still Allowing Callbacks",id:"adding-promise-support-while-still-allowing-callbacks",level:2},{value:"Speculation: Why the Official Snowflake SDK is not Fully Promisified",id:"speculation-why-the-official-snowflake-sdk-is-not-fully-promisified",level:2},{value:"How we Addressed This Issue",id:"how-we-addressed-this-issue",level:3},{value:"SDK Compatibility",id:"sdk-compatibility",level:2},{value:"Compatibility with Previous Versions",id:"compatibility-with-previous-versions",level:2},{value:"TypeScript Compatibility",id:"typescript-compatibility",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"key-implementation-details",children:"Key Implementation Details"})}),"\n","\n",(0,s.jsx)(i.p,{children:"This page discusses selected implementation details of the library."}),"\n",(0,s.jsx)(i.p,{children:"This library aims to:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Help developers use Snowflake more intuitively through Promises."}),"\n",(0,s.jsx)(i.li,{children:"Stay maintainable with a lightweight approach to enhancing the Snowflake API."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"proxying-the-connection",children:"Proxying the Connection"}),"\n",(0,s.jsxs)(i.p,{children:["To add Promise support to the Snowflake SDK ",(0,s.jsx)(i.code,{children:"Connection"})," type, we use a ",(0,s.jsx)(i.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",children:"JavaScript Proxy"}),". This allows us to intercept and modify the behavior of the original methods."]}),"\n",(0,s.jsxs)(i.p,{children:["A JavaScript Proxy has advantages over the traditional ",(0,s.jsx)(i.a,{href:"https://refactoring.guru/design-patterns/proxy",children:"Proxy design pattern"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["We only need to trap specific methods, not implement the entire interface.","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"This greatly improves maintainability."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.li,{children:"The JavaScript proxy maintains the same prototype as the original object, ensuring it works anywhere the original would work."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"adding-promise-support-while-still-allowing-callbacks",children:"Adding Promise Support While Still Allowing Callbacks"}),"\n",(0,s.jsxs)(i.p,{children:["A ",(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," can still be used with callbacks."]}),"\n",(0,s.jsx)(i.p,{children:"Our promisify method creates a wrapper that detects if a callback is provided. With a callback, it runs the original method as-is. Without a callback, it returns a Promise that resolves with the method\u2019s result."}),"\n",(0,s.jsx)(i.p,{children:"This approach maintains backward compatibility with existing callback code."}),"\n",(0,s.jsx)(i.h2,{id:"speculation-why-the-official-snowflake-sdk-is-not-fully-promisified",children:"Speculation: Why the Official Snowflake SDK is not Fully Promisified"}),"\n",(0,s.jsxs)(i.p,{children:["The official Snowflake SDK is partially promisified, but key methods like ",(0,s.jsx)(i.code,{children:"execute"})," are not."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"execute"})," needs to return two different things at two different times:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The Statement object needs to be returned immediately, as it is used to manage the result set."}),"\n",(0,s.jsx)(i.li,{children:"The results need to be returned later, when execution has completed."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Callback-based APIs allow this. They return two different values at two different times: one value returned as the immediate result, and another value returned later via callback."}),"\n",(0,s.jsx)(i.h3,{id:"how-we-addressed-this-issue",children:"How we Addressed This Issue"}),"\n",(0,s.jsxs)(i.p,{children:["To fully support this functionality while using promises, we return an object that contains two values: the Statement object and a ",(0,s.jsx)(i.code,{children:"Promise"})," that resolves with the results:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"// The fully-annotated type for the `execute` method\u2019s return type\ntype StatementOptionMethodResult<RowType> = {\n  statement: PromisifiedRowStatement;\n  resultsPromise: Promise<Array<RowType> | undefined>;\n};\n"})}),"\n",(0,s.jsxs)(i.p,{children:["This means that the caller has immediate access to the Statement object, which can be used to manage the result set, while the results are a ",(0,s.jsx)(i.code,{children:"Promise"}),", which can be awaited."]}),"\n",(0,s.jsx)(i.h2,{id:"sdk-compatibility",children:"SDK Compatibility"}),"\n",(0,s.jsx)(i.p,{children:"We have improved compatibility with the Snowflake SDK compared to the original library."}),"\n",(0,s.jsxs)(i.p,{children:["The new version of the library makes the Snowflake SDK a ",(0,s.jsx)(i.code,{children:"peerDependency"})," instead of a direct dependency. This prevents version conflicts and allows use of newer SDK versions."]}),"\n",(0,s.jsx)(i.p,{children:"In addition, authentication and other core functionality are no longer passed through the helper library, but are handled directly by the Snowflake SDK itself, reducing compatibility concerns as Snowflake\u2019s authentication requirements evolve."}),"\n",(0,s.jsx)(i.h2,{id:"compatibility-with-previous-versions",children:"Compatibility with Previous Versions"}),"\n",(0,s.jsx)(i.p,{children:"The API has changed significantly since the previous version."}),"\n",(0,s.jsxs)(i.p,{children:["The previous version used ",(0,s.jsx)(i.code,{children:"Snowflake"}),", ",(0,s.jsx)(i.code,{children:"Connection"}),", and ",(0,s.jsx)(i.code,{children:"Statement"})," objects that acted as proxies over the SDK. These objects gradually fell behind SDK updates over time."]}),"\n",(0,s.jsx)(i.p,{children:"For backward compatibility, these objects are still available. While your existing code will continue to work, we recommend migrating to the new API for better future compatibility."}),"\n",(0,s.jsxs)(i.p,{children:["For details, see the ",(0,s.jsx)(i.a,{href:"../migration-guide",children:"Migration Guide"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"typescript-compatibility",children:"TypeScript Compatibility"}),"\n",(0,s.jsx)(i.p,{children:"We provide TypeScript type definitions for all enhanced SDK methods."}),"\n",(0,s.jsxs)(i.p,{children:["We implemented these type definitions by creating a new ",(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," interface that extends Snowflake\u2019s original ",(0,s.jsx)(i.code,{children:"Connection"})," interface. This approach ensures:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Regular ",(0,s.jsx)(i.code,{children:"Connection"})," objects don\u2019t display promisified methods in your IDE."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," objects have strongly typed promise-based methods that are displayed in your IDE and validated by TypeScript."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," objects are still fully compatible with the original ",(0,s.jsx)(i.code,{children:"Connection"})," interface.","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Remember that you can still use callbacks, even on ",(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," objects, so it is safe to pass them to functions that expect standard ",(0,s.jsx)(i.code,{children:"Connection"})," objects, and TypeScript understands this."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>l,x:()=>a});var n=t(6540);const s={},o=n.createContext(s);function l(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);