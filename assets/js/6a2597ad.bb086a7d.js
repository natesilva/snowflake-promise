"use strict";(self.webpackChunksnowflake_promise_website=self.webpackChunksnowflake_promise_website||[]).push([[1424],{1636:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"implementation-details","title":"Implementation Details","description":"This page explains how the library works internally and key design decisions.","source":"@site/docs/implementation-details.mdx","sourceDirName":".","slug":"/implementation-details","permalink":"/snowflake-promise/docs/implementation-details","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Implementation Details"},"sidebar":"tutorialSidebar","previous":{"title":"Authentication and MFA","permalink":"/snowflake-promise/docs/authentication-and-mfa"},"next":{"title":"Legacy Migration Guide","permalink":"/snowflake-promise/docs/migration-guide"}}');var s=n(4848),r=n(8453);const o={sidebar_position:7,title:"Implementation Details"},l=void 0,a={},c=[{value:"Design Goals",id:"design-goals",level:2},{value:"How Proxying Works",id:"how-proxying-works",level:2},{value:"Traditional Proxy Pattern vs. JavaScript Proxy",id:"traditional-proxy-pattern-vs-javascript-proxy",level:3},{value:"Dual Promise/Callback Support",id:"dual-promisecallback-support",level:2},{value:"Why Not <code>util.promisify</code>?",id:"why-not-utilpromisify",level:3},{value:"Our Custom Solution",id:"our-custom-solution",level:3},{value:"The <code>execute</code> Method Challenge",id:"the-execute-method-challenge",level:2},{value:"The Solution Pattern",id:"the-solution-pattern",level:3},{value:"SDK Compatibility Improvements",id:"sdk-compatibility-improvements",level:2},{value:"Legacy API Compatibility",id:"legacy-api-compatibility",level:2},{value:"TypeScript Support",id:"typescript-support",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"This page explains how the library works internally and key design decisions."}),"\n",(0,s.jsx)(i.h2,{id:"design-goals",children:"Design Goals"}),"\n",(0,s.jsx)(i.p,{children:"This library aims to:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Help developers use Snowflake more intuitively through Promises."}),"\n",(0,s.jsx)(i.li,{children:"Stay maintainable with a lightweight approach to enhancing the Snowflake API."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"how-proxying-works",children:"How Proxying Works"}),"\n",(0,s.jsxs)(i.p,{children:["To add Promise support to the Snowflake SDK ",(0,s.jsx)(i.code,{children:"Connection"}),", we use a ",(0,s.jsx)(i.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",children:"JavaScript Proxy"})," to intercept and modify method calls."]}),"\n",(0,s.jsx)(i.h3,{id:"traditional-proxy-pattern-vs-javascript-proxy",children:"Traditional Proxy Pattern vs. JavaScript Proxy"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Traditional Proxy Pattern"}),": Requires implementing a complete wrapper class that mirrors the entire target interface. Every method must be explicitly implemented, creating significant maintenance overhead as the interface evolves. This is how the previous version of this library was implemented."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"JavaScript Proxy"}),": Uses a \u201ctrap\u201d system where you only define handlers for specific operations you want to intercept. All other operations automatically pass through without additional code."]}),"\n",(0,s.jsx)(i.p,{children:"Key advantages:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Selective enhancement"}),": We only trap specific methods (",(0,s.jsx)(i.code,{children:"connect"}),", ",(0,s.jsx)(i.code,{children:"execute"}),"), not the entire interface."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Automatic pass-through"}),": Untrapped methods and properties work exactly like the original object."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Future-proof"}),": New SDK methods work immediately without code changes."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Full compatibility"}),": Maintains the same prototype, so it works anywhere the original would."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"dual-promisecallback-support",children:"Dual Promise/Callback Support"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," objects work with both Promises and callbacks."]}),"\n",(0,s.jsxs)(i.h3,{id:"why-not-utilpromisify",children:["Why Not ",(0,s.jsx)(i.code,{children:"util.promisify"}),"?"]}),"\n",(0,s.jsxs)(i.p,{children:["Node.js\u2019s ",(0,s.jsx)(i.code,{children:"util.promisify"})," appears to support both callbacks and Promises, but this is an accidental side effect with several problems:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Always returns a Promise"}),": Even when a callback is provided, ",(0,s.jsx)(i.code,{children:"util.promisify"})," returns a Promise."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Always appends a callback"}),": It adds its own callback to the argument list regardless of user input."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Callback duplication"}),": If a user passes a callback, the argument list ends up with two callbacks - the user\u2019s callback followed by ",(0,s.jsx)(i.code,{children:"util.promisify"}),"\u2019s callback. The user\u2019s callback will be called, but the ",(0,s.jsx)(i.code,{children:"util.promisify"})," callback, which finalizes the Promise, is never called, leaving an unresolved Promise."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"our-custom-solution",children:"Our Custom Solution"}),"\n",(0,s.jsx)(i.p,{children:"Our wrapper detects whether a callback is provided:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"With callback"}),": Runs the original SDK method unchanged, returns ",(0,s.jsx)(i.code,{children:"void"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Without callback"}),": Returns a Promise that resolves with the result."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This provides true dual-mode operation with complete backward compatibility."}),"\n",(0,s.jsxs)(i.h2,{id:"the-execute-method-challenge",children:["The ",(0,s.jsx)(i.code,{children:"execute"})," Method Challenge"]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"execute"})," method needs to return two things at different times:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Immediately"}),": The Statement object for query management."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Later"}),": The actual query results when execution completes."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Traditional Promise APIs return a single async value, making this pattern difficult to implement cleanly."}),"\n",(0,s.jsx)(i.h3,{id:"the-solution-pattern",children:"The Solution Pattern"}),"\n",(0,s.jsx)(i.p,{children:"Our approach is to return an object containing both the immediate value and a Promise for the async result:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"type StatementOptionMethodResult<RowType> = {\n  statement: PromisifiedRowStatement;\n  resultsPromise: Promise<Array<RowType> | undefined>;\n};\n"})}),"\n",(0,s.jsx)(i.p,{children:"This pattern provides:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Immediate access"})," to the Statement object for query management."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Promise-based access"})," to results that can be awaited."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This maintains full callback API functionality while enabling modern async/await patterns."}),"\n",(0,s.jsx)(i.h2,{id:"sdk-compatibility-improvements",children:"SDK Compatibility Improvements"}),"\n",(0,s.jsx)(i.p,{children:"Key improvements over the original library:"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Peer Dependency"}),": The Snowflake SDK is now a ",(0,s.jsx)(i.code,{children:"peerDependency"}),", preventing version conflicts and enabling newer SDK versions."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Direct SDK Usage"}),": Authentication and core functionality are handled directly by the SDK, not passed through this library. This reduces compatibility concerns as requirements evolve."]}),"\n",(0,s.jsx)(i.h2,{id:"legacy-api-compatibility",children:"Legacy API Compatibility"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Previous approach"}),": Used ",(0,s.jsx)(i.code,{children:"Snowflake"}),", ",(0,s.jsx)(i.code,{children:"Connection"}),", and ",(0,s.jsx)(i.code,{children:"Statement"})," proxy objects that fell behind SDK updates."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Current approach"}),": Direct SDK enhancement with minimal wrapper code."]}),"\n",(0,s.jsxs)(i.p,{children:["Legacy objects remain available for backward compatibility. See the ",(0,s.jsx)(i.a,{href:"../migration-guide",children:"Migration Guide"})," for migration details."]}),"\n",(0,s.jsx)(i.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,s.jsxs)(i.p,{children:["We provide complete TypeScript definitions via a ",(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," interface that extends the original ",(0,s.jsx)(i.code,{children:"Connection"})," interface."]}),"\n",(0,s.jsx)(i.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Clean separation"}),": Regular ",(0,s.jsx)(i.code,{children:"Connection"})," objects don\u2019t show promisified methods in your IDE."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Strong typing"}),": ",(0,s.jsx)(i.code,{children:"PromisifiedConnection"})," objects have fully typed Promise methods with IDE support."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Full compatibility"}),": Works anywhere ",(0,s.jsx)(i.code,{children:"Connection"})," objects do, including with callback-based functions. TypeScript intelligently recognizes the usage pattern - when a callback is provided, it types the return the same way as the underlying SDK function; when no callback is provided, it correctly types the return as a ",(0,s.jsx)(i.code,{children:"Promise"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>l});var t=n(6540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);